{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red79\green122\blue61;\red255\green255\blue255;\red172\green173\blue193;
\red71\green137\blue205;\red212\green212\blue212;\red167\green197\blue151;\red45\green175\blue118;\red238\green114\blue173;
\red17\green112\blue148;\red194\green126\blue101;\red252\green180\blue12;\red187\green96\blue43;\red139\green107\blue10;
\red31\green133\blue64;}
{\*\expandedcolortbl;;\cssrgb\c37609\c54466\c30476;\cssrgb\c100000\c100000\c100000\c0;\cssrgb\c73059\c73457\c80033;
\cssrgb\c33936\c61427\c84130;\cssrgb\c86370\c86370\c86262;\cssrgb\c71008\c80807\c65805;\cssrgb\c19586\c72947\c53683;\cssrgb\c95320\c54126\c73246;
\cssrgb\c3457\c51349\c64890;\cssrgb\c80778\c56830\c46925;\cssrgb\c99664\c75273\c2206;\cssrgb\c78724\c45738\c22110;\cssrgb\c61751\c49155\c2803;
\cssrgb\c12866\c57979\c31656;}
\paperw11900\paperh16840\margl1440\margr1440\vieww18940\viewh14280\viewkind0
\deftab720
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
// SPDX-License-Identifier: GPL-3.0\cf4 \
\cf5 pragma\cf4  \cf5 solidity\cf4  \cf6 >=\cf7 0.7.0\cf4  \cf6 <\cf7 0.9.0\cf6 ;\cf4 \
\
\cf2 /***************************************************************************************************************/\cf4 \
\cf2 /***************************************************************************************************************/\cf4 \
\cf2 /*  Contract to facilitate car rental              \cf4 \
\cf2 /*  Car type available:                            \cf4 \
\cf2 /*    a. 4-seater = 1 ETH/day                      \cf4 \
\cf2 /*    b. 6-seater = 2 ETH/day                      \cf4 \
\cf2 /*    c. 8-seater = 3 ETH/day \cf4 \
\cf2 /*\cf4 \
\cf2 /*  Process flow:\cf4 \
\cf2 /*    1. Company's wallet account deploys the contract \cf4 \
\cf2 /*    2. Listing of car fleet for rent \cf4 \
\cf2 /*       - only company's account can add\cf4 \
\cf2 /*       - 10ETH to be added into the contract for each car to instill confidence of availability\cf4 \
\cf2 /*    3. Customer check availability \cf4 \
\cf2 /*       - check that value in contract now matches number of cars available with ratio 1car:10ETH \cf4 \
\cf2 /*    4. Customer choose a available car to rent and deposit 10ETH per number of days intended to rent to show commitment. \cf4 \
\cf2 /*       - Will fail if user has a prior rental record that indicates existing outstanding fees. Proceed to pay fine if so.  \cf4 \
\cf2 /*    5. Once deposit received from customer, company release car key to customer and key in start date. Contract amount will be reduced.  \cf4 \
\cf2 /*    6. Car returned, company key in end date to calculate cost of rent base on days. Cost of any damage will be added to the total cost\cf4 \
\cf2 /*       - Deduct from deposit; if extra will be returned to customer, shortfall will be recorded as outstanding fees which until it is paid, \cf4 \
\cf2 /*         will not allow user to rent\cf4 \
\cf2 /*    7. Once done, avail the car by changing state to available \cf4 \
\cf2 /****************************************************************************************************************/\cf4 \
\cf2 /****************************************************************************************************************/\cf4 \
\
\cf5 contract\cf4  CarRental \cf6 \{\cf4 \
\
  \cf2 /********************************************************************************************************/\cf4 \
  \cf2 /*                                           Declarations                                               */\cf4 \
  \cf2 /********************************************************************************************************/\cf4 \
\
    \cf2 // Designing a structure to store the information of ABC Rental company's car fleet \cf4 \
    \cf5 struct\cf4  carInfo \cf6 \{\cf4 \
      \cf5 string\cf4  carPlate\cf6 ;\cf4  \
      \cf5 string\cf4  carInfo\cf6 ;\cf4  \cf2 // Short description about car\cf4 \
      \cf5 uint\cf4  carType\cf6 ;\cf4  \cf2 // How many seater: 4/6/8\cf4 \
      \cf5 bool\cf4  carAvailable\cf6 ;\cf4  \cf2 // True: Available, False: N.Available \cf4 \
    \cf6 \}\cf4 \
\
    \cf2 // Designing a structure to store the information of Customers.  \cf4 \
    \cf5 struct\cf4  customerInfo \cf6 \{\cf4 \
      \cf5 string\cf4  name\cf6 ;\cf4  \
      \cf5 string\cf4  identityNum\cf6 ;\cf4   \
      \cf5 uint\cf4  age\cf6 ;\cf4 \
      \cf5 string\cf4  resiAdd\cf6 ;\cf4  \cf2 // Residential address\cf4 \
      \cf5 address\cf4  walletAdd\cf6 ;\cf4  \cf2 // Wallet address of customer\cf4 \
    \cf6 \}\cf4 \
\
    \cf2 // Designing a structure to store the car renting history \cf4 \
    \cf5 struct\cf4  rentalHistory \cf6 \{\cf4 \
      \cf5 string\cf4  carPlate\cf6 ;\cf4  \
      \cf5 string\cf4  name\cf6 ;\cf4    \
      \cf5 address\cf4  walletAdd\cf6 ;\cf4 \
      \cf5 uint\cf4  depositAmt\cf6 ;\cf4 \
      \cf5 uint\cf4  startDate\cf6 ;\cf4   \
      \cf5 uint\cf4  endDate\cf6 ;\cf4 \
      \cf5 uint\cf4  numOfDays\cf6 ;\cf4  \cf2 // Number of days user intend to rent\cf4 \
      \cf5 bool\cf4  carReturned\cf6 ;\cf4 \
      \cf5 uint\cf4  outstandingFee\cf6 ;\cf4 \
      \cf6 \}\cf4 \
\
    \cf2 // enum State \{ Unavailable, Available \}\cf4 \
    \cf2 // State public carState;\cf4 \
    \cf5 address\cf4  \cf8 payable\cf4  \cf8 public\cf4  company\cf6 ;\cf4  \cf2 // the address of the company's account\cf4 \
    \cf5 uint\cf4  \cf8 public\cf4  contractBalance \cf6 =\cf4  \cf7 0\cf6 ;\cf4  \cf2 // to check the current balance in the contract if it matches availability of cars\cf4 \
    \cf5 uint\cf4  \cf8 public\cf4  carCnt \cf6 =\cf4  \cf7 0\cf6 ;\cf4  \cf2 // to count the number of the cars added\cf4 \
    \cf5 uint\cf4  \cf8 public\cf4  customerCnt \cf6 =\cf4  \cf7 0\cf6 ;\cf4  \cf2 // to count the number of the customers\cf4 \
    \cf5 uint\cf4  \cf8 public\cf4  recordCnt \cf6 =\cf4  \cf7 0\cf6 ;\cf4  \cf2 // to count the number of the rental records \cf4 \
\
    \cf5 mapping\cf6 (\cf5 uint\cf4  => carInfo\cf6 )\cf4  \cf8 public\cf4  cars\cf6 ;\cf4  \cf2 // to store the information of each car type\cf4 \
    \cf5 mapping\cf6 (\cf5 uint\cf4  => customerInfo\cf6 )\cf4  customers\cf6 ;\cf4  \cf2 // to store the information of each car type\cf4 \
    \cf5 mapping\cf6 (\cf5 uint\cf4  => rentalHistory\cf6 )\cf4  \cf8 public\cf4  records\cf6 ;\cf4  \cf2 // to store the rental records: the customer address to the index of car he/she rent\cf4 \
\
\
  \cf2 /********************************************************************************************************/\cf4 \
  \cf2 /*                                           Constructor                                                */\cf4 \
  \cf2 /********************************************************************************************************/\cf4 \
\
    \cf9 constructor\cf6 ()\cf4  \cf8 payable\cf4  \cf6 \{\cf4 \
        company \cf6 =\cf4  \cf8 payable\cf6 (\cf10 msg\cf6 .\cf4 sender\cf6 );\cf4 \
    \cf6 \}\cf4 \
\
\
  \cf2 /********************************************************************************************************/\cf4 \
  \cf2 /*                                           Modifiers                                                  */\cf4 \
  \cf2 /********************************************************************************************************/\cf4 \
\
    \cf2 // To check msg.sender is the company\cf4 \
    \cf5 modifier\cf4  isCompany\cf6 ()\cf4  \cf6 \{\cf4 \
        \cf10 require\cf6 (\cf10 msg\cf6 .\cf4 sender \cf6 ==\cf4  company\cf6 ,\cf4  \cf11 "Only company can add car information."\cf6 );\cf4 \
        _\cf6 ;\cf4 \
    \cf6 \}\cf4 \
\
    \cf2 // To check critical car info entered is correct\cf4 \
    \cf5 modifier\cf4  infoCorrect\cf6 (\cf5 uint\cf4  seaterNum\cf6 ,\cf4  \cf5 uint\cf4  carStatus\cf6 )\cf4  \cf6 \{\cf4 \
        \cf5 bool\cf4  numvalid \cf6 =\cf4  \cf5 false\cf6 ;\cf4 \
        \cf5 bool\cf4  statusvalid \cf6 =\cf4  \cf5 false\cf6 ;\cf4 \
        \cf12 if\cf4  \cf6 (\cf4 seaterNum \cf6 ==\cf4  \cf7 4\cf4  \cf6 ||\cf4  seaterNum \cf6 ==\cf4  \cf7 6\cf4  \cf6 ||\cf4  seaterNum \cf6 ==\cf4  \cf7 8\cf6 )\cf4  \cf6 \{\cf4 \
            numvalid \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
        \cf6 \}\cf4 \
\
        \cf12 if\cf4  \cf6 (\cf4 carStatus \cf6 ==\cf4  \cf7 0\cf4  \cf6 ||\cf4  carStatus \cf6 ==\cf4  \cf7 1\cf6 )\cf4  \cf6 \{\cf4 \
            statusvalid \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
        \cf6 \}\cf4 \
        \cf10 require\cf6 (\cf4 numvalid \cf6 ==\cf4  \cf5 true\cf6 ,\cf4  \cf11 "Seater options is only 4, 6 or 8"\cf6 );\cf4 \
        \cf10 require\cf6 (\cf4 statusvalid \cf6 ==\cf4  \cf5 true\cf6 ,\cf4  \cf11 "Car Status 0:Unavailable, 1:Available"\cf6 );\cf4 \
        _\cf6 ;\cf4 \
    \cf6 \}\cf4 \
\
    \cf2 // To check the car is available\cf4 \
    \cf5 modifier\cf4  isAvailable\cf6 (\cf5 uint\cf4  typeId\cf6 )\cf4  \cf6 \{\cf4 \
      \cf10 require\cf6 (\cf4 cars\cf6 [\cf4 typeId\cf6 ].\cf4 carAvailable \cf6 ==\cf4  \cf5 true\cf6 ,\cf4  \cf11 "This car is not available, choose another one!"\cf6 );\cf4 \
      _\cf6 ;\cf4 \
    \cf6 \}\cf4 \
    \
    \cf2 // To check the msg.value is twice of the rent\cf4 \
    \cf5 modifier\cf4  isEnough\cf6 (\cf5 uint\cf4  numOfDays\cf6 )\cf4  \cf6 \{\cf4 \
      \cf10 require\cf6 (\cf10 msg\cf6 .\cf4 value \cf6 >=\cf4  \cf7 10\cf4  ether \cf6 *\cf4  numOfDays\cf6 ,\cf4  \
             \cf11 "ETH Value sent in is not enough for deposit for the number of days intended to rent."\cf6 );\cf4 \
      _\cf6 ;\cf4 \
    \cf6 \}\cf4 \
\
    \cf2 // To check the renter has no past outstanding fees before renting\cf4 \
    \cf5 modifier\cf4  noOutstanding\cf6 (\cf5 address\cf4  walletAddress\cf6 )\cf4  \cf6 \{\cf4 \
      \cf5 bool\cf4  pass \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
\
      \cf13 for\cf4  \cf6 (\cf5 uint\cf4  i \cf6 =\cf4  recordCnt\cf6 ;\cf4  i \cf6 >\cf4  \cf7 0\cf6 ;\cf4  i\cf6 --)\cf4  \cf6 \{\cf4 \
        \cf12 if\cf4  \cf6 (\cf4 records\cf6 [\cf4 i\cf6 -\cf7 1\cf6 ].\cf4 walletAdd \cf6 ==\cf4  walletAddress\cf6 )\cf4  \cf6 \{\cf4 \
          \cf12 if\cf4  \cf6 (\cf4 records\cf6 [\cf4 i\cf6 -\cf7 1\cf6 ].\cf4 outstandingFee \cf6 !=\cf4  \cf7 0\cf6 )\cf4  \cf6 \{\cf4 \
            \cf2 // If the latest record available for this wallet address shows outstanding fee, renter is not allowed to rent\cf4 \
            pass \cf6 =\cf4  \cf5 false\cf6 ;\cf4 \
            \cf13 break\cf6 ;\cf4 \
          \cf6 \}\cf4 \
          \cf12 else\cf4  \cf12 if\cf4  \cf6 (\cf4 records\cf6 [\cf4 i\cf6 -\cf7 1\cf6 ].\cf4 outstandingFee \cf6 ==\cf4  \cf7 0\cf6 )\cf4  \cf6 \{\cf4 \
            \cf2 // If the latest record available for this wallet address shows no outstanding fee, no need to check earlier records anymore.\cf4 \
            pass \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
            \cf13 break\cf6 ;\cf4 \
          \cf6 \}\cf4 \
        \cf6 \}\cf4 \
        \cf12 else\cf4  \cf12 if\cf4  \cf6 (\cf4 i\cf6 ==\cf7 0\cf6 )\cf4  \cf6 \{\cf4 \
          \cf2 // No record of this wallet add yet, proceed to rent car\cf4 \
          pass \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
        \cf6 \}\cf4 \
      \cf6 \}\cf4 \
      \cf10 require\cf6 (\cf4 pass \cf6 ==\cf4  \cf5 true\cf6 ,\cf4  \cf11 "You have outstanding fees from previous rental, please proceed to pay your fee using pay fee function!"\cf6 );\cf4 \
      _\cf6 ;\cf4 \
    \cf6 \}\cf4 \
\
\
\
  \cf2 /********************************************************************************************************/\cf4 \
  \cf2 /*                                           Functions                                                  */\cf4 \
  \cf2 /********************************************************************************************************/\cf4 \
\
    \cf2 // Flow 2: Listing of car fleet for rent  \cf4 \
    \cf2 // The company should add information of the car type\cf4 \
    \cf5 function\cf4  addCarInfo\cf6 (\cf5 string\cf4  \cf14 memory\cf4  carPlateNum\cf6 ,\cf4  \cf5 string\cf4  \cf14 memory\cf4  carDescription\cf6 ,\cf4  \cf5 uint\cf4  seaterNum\cf6 ,\cf4  \cf5 uint\cf4  carStatus\cf6 )\cf4  \
    \cf8 payable\cf4  \cf8 public\cf4  isCompany infoCorrect\cf6 (\cf4 seaterNum\cf6 ,\cf4  carStatus\cf6 )\cf4  \cf6 \{\cf4 \
        \cf5 bool\cf4  carAvail \cf6 =\cf4  \cf5 false\cf6 ;\cf4 \
        \cf5 bool\cf4  unique \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
        \cf12 if\cf4  \cf6 (\cf4 carStatus \cf6 ==\cf4  \cf7 1\cf6 )\cf4  \cf6 \{\cf4 \
            carAvail \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
        \cf6 \}\cf4 \
\
        \cf2 // Convert carplate to lowercase, then compare with existing cars list to make sure we dont list the same car twice\cf4 \
        \cf13 for\cf4  \cf6 (\cf5 uint\cf4  i \cf6 =\cf4  \cf7 0\cf6 ;\cf4  i \cf6 <\cf4  carCnt\cf6 +\cf7 1\cf6 ;\cf4  i\cf6 ++)\cf4  \cf6 \{\cf4 \
            \cf12 if\cf4  \cf6 (\cf10 keccak256\cf6 (\cf10 bytes\cf6 (\cf4 _toLower\cf6 (\cf4 cars\cf6 [\cf4 i\cf6 ].\cf4 carPlate\cf6 )))\cf4  \cf6 ==\cf4  \cf10 keccak256\cf6 (\cf10 bytes\cf6 (\cf4 _toLower\cf6 (\cf4 carPlateNum\cf6 ))))\cf4  \cf6 \{\cf4 \
                unique \cf6 =\cf4  \cf5 false\cf6 ;\cf4 \
                \cf13 break\cf6 ;\cf4  \
            \cf6 \}\cf4 \
        \cf6 \}\cf4 \
        \cf10 require\cf6 (\cf4 unique \cf6 ==\cf4  \cf5 true\cf6 ,\cf4  \cf11 "You have added this car plate before!"\cf6 );\cf4 \
        \cf10 require\cf6 (\cf10 msg\cf6 .\cf4 value \cf6 ==\cf4  \cf7 10\cf4  ether\cf6 ,\cf4  \cf11 "The company has to deposit 10 ETH to instill confidence of car availability!"\cf6 );\cf4 \
        \
        \cf2 // Update contract balance\cf4 \
        contractBalance \cf6 =\cf4  contractBalance \cf6 +\cf4  \cf10 msg\cf6 .\cf4 value\cf6 ;\cf4 \
\
        \cf2 // Only add if verified car plate has never been uploaded before\cf4 \
        cars\cf6 [\cf4 carCnt\cf6 ]\cf4  \cf6 =\cf4  carInfo\cf6 (\cf4 carPlateNum\cf6 ,\cf4  carDescription\cf6 ,\cf4  seaterNum\cf6 ,\cf4  carAvail\cf6 );\cf4 \
        carCnt\cf6 ++;\cf4 \
    \cf6 \}\cf4 \
\
\
    \cf2 // Flow 3: Check availability  \cf4 \
    \cf5 function\cf4  carID_checkAvailability\cf6 (\cf5 uint\cf4  seaterNum\cf6 )\cf4  \
    \cf8 public\cf4  \cf8 view\cf4  \cf15 returns\cf6 (\cf4  \cf5 uint\cf6 []\cf4  \cf14 memory\cf6 )\cf4  \cf6 \{\cf4 \
      \cf2 // Allow user to input preference base on seater number, then we loop       \cf4 \
      \cf2 // through the dynamic list: cars, and output all those that carAvailabile = true\cf4 \
      \cf2 // Also to provide total contract balance to see if it matches the number of cars available for confidence\cf4 \
      \cf10 require\cf6 (\cf4 seaterNum \cf6 ==\cf4  \cf7 4\cf4  \cf6 ||\cf4  seaterNum \cf6 ==\cf4  \cf7 6\cf4  \cf6 ||\cf4  seaterNum \cf6 ==\cf7 8\cf6 ,\cf4  \cf11 "We only have 4/6/8-seater cars! "\cf6 );\cf4 \
      \cf10 require\cf6 (\cf4 carCnt \cf6 >\cf4  \cf7 0\cf6 ,\cf4  \cf11 "No cars listed yet!"\cf6 );\cf4 \
\
      \cf5 uint\cf4  resultCount\cf6 ;\cf4 \
      \cf13 for\cf4  \cf6 (\cf5 uint\cf4  i \cf6 =\cf4  \cf7 0\cf6 ;\cf4  i \cf6 <\cf4  carCnt\cf6 +\cf7 1\cf6 ;\cf4  i\cf6 ++)\cf4  \cf6 \{\cf4 \
        \cf12 if\cf4  \cf6 (\cf4 cars\cf6 [\cf4 i\cf6 ].\cf4 carAvailable \cf6 &&\cf4  cars\cf6 [\cf4 i\cf6 ].\cf4 carType \cf6 ==\cf4  seaterNum\cf6 )\cf4  \cf6 \{\cf4 \
          resultCount\cf6 ++;\cf4     \cf2 // determine the result count\cf4 \
        \cf6 \}\cf4 \
      \cf6 \}\cf4 \
      \
      \cf2 //create the fixed-length array\cf4 \
      \cf5 uint\cf6 []\cf4  \cf14 memory\cf4  result \cf6 =\cf4  \cf5 new\cf4  \cf5 uint\cf6 [](\cf4 resultCount\cf6 );\cf4  \
      \cf5 uint\cf4  j\cf6 ;\cf4 \
      \cf13 for\cf4  \cf6 (\cf5 uint\cf4  i \cf6 =\cf4  \cf7 0\cf6 ;\cf4  i \cf6 <\cf4  carCnt\cf6 +\cf7 1\cf6 ;\cf4  i\cf6 ++)\cf4  \cf6 \{\cf4 \
        \cf12 if\cf4  \cf6 (\cf4 cars\cf6 [\cf4 i\cf6 ].\cf4 carAvailable \cf6 &&\cf4  cars\cf6 [\cf4 i\cf6 ].\cf4 carType \cf6 ==\cf4  seaterNum\cf6 )\cf4  \cf6 \{\cf4 \
          result\cf6 [\cf4 j\cf6 ++]\cf4  \cf6 =\cf4  i\cf6 ;\cf4     \cf2 // fill the array\cf4 \
        \cf6 \}\cf4 \
      \cf6 \}\cf4 \
      \
      \cf2 // Output: recommendation of cars typeId list (index number) e.g 2,3,5\cf4 \
      \cf15 return\cf4  result\cf6 ;\cf4 \
    \cf6 \}\cf4 \
\
\
    \cf2 // Flow 4 & 5: Choose car that is available, Once deposit received from customer, company release car key to customer and key in start date. Contract amount will be reduced.\cf4 \
    \cf2 // The customer should deposit 10ETH * num of days they intend to rent \cf4 \
    \cf5 function\cf4  rentCar\cf6 (\cf5 uint\cf4  carID\cf6 ,\cf4  \cf5 uint\cf4  duration\cf6 ,\cf4  \cf5 string\cf4  \cf14 memory\cf4  Name\cf6 ,\cf4 \
      \cf5 string\cf4  \cf14 memory\cf4  IDnum\cf6 ,\cf4  \cf5 uint\cf4  age\cf6 ,\cf4  \cf5 string\cf4  \cf14 memory\cf4  resiAddress\cf6 ,\cf4  \cf5 address\cf4  walletAddress\cf6 )\cf4  \
      \cf8 payable\cf4  \cf8 public\cf4  isAvailable\cf6 (\cf4 carID\cf6 )\cf4  isEnough\cf6 (\cf4 duration\cf6 )\cf4  noOutstanding\cf6 (\cf10 msg\cf6 .\cf4 sender\cf6 )\cf4  \cf6 \{\cf4 \
        \cf10 require\cf6 (\cf4 walletAddress \cf6 ==\cf4  \cf10 msg\cf6 .\cf4 sender\cf6 ,\cf4  \cf11 "You must rent car using your own wallet address!"\cf6 );\cf4 \
        \cf10 require\cf6 (\cf4 age \cf6 >=\cf4  \cf7 21\cf6 ,\cf4  \cf11 "You must be at least 21 years old to rent a car!"\cf6 );\cf4 \
        \cf10 require\cf6 (\cf4 cars\cf6 [\cf4 carID\cf6 ].\cf4 carAvailable \cf6 ==\cf4  \cf5 true\cf6 ,\cf4  \
                \cf11 "This car is currently not available, use carID_checkAvailability to find out which carID is available!"\cf6 );\cf4 \
\
        \cf2 // Update contract balance\cf4 \
        contractBalance \cf6 =\cf4  contractBalance \cf6 +\cf4  \cf10 msg\cf6 .\cf4 value\cf6 ;\cf4 \
\
        \cf5 bool\cf4  unique \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
        \cf2 // uint start = block.timestamp;\cf4 \
        \cf2 // uint end = start + (duration * 1 days);\cf4 \
        \
        \cf2 // Customer database: Record customer info if unique\cf4 \
        \cf13 for\cf4  \cf6 (\cf5 uint\cf4  i \cf6 =\cf4  \cf7 0\cf6 ;\cf4  i \cf6 <\cf4  customerCnt\cf6 +\cf7 1\cf6 ;\cf4  i\cf6 ++)\cf4  \cf6 \{\cf4 \
          \cf12 if\cf4  \cf6 (\cf10 keccak256\cf6 (\cf10 bytes\cf6 (\cf4 _toLower\cf6 (\cf4 customers\cf6 [\cf4 i\cf6 ].\cf4 identityNum\cf6 )))\cf4  \cf6 ==\cf4  \cf10 keccak256\cf6 (\cf10 bytes\cf6 (\cf4 _toLower\cf6 (\cf4 IDnum\cf6 ))))\cf4  \cf6 \{\cf4 \
            unique \cf6 =\cf4  \cf5 false\cf6 ;\cf4 \
            \cf13 break\cf6 ;\cf4 \
          \cf6 \}\cf4 \
        \cf6 \}\cf4 \
        \cf12 if\cf4  \cf6 (\cf4 unique\cf6 )\cf4  \cf6 \{\cf4 \
          customers\cf6 [\cf4 customerCnt\cf6 ]\cf4  \cf6 =\cf4  customerInfo\cf6 (\cf4 Name\cf6 ,\cf4  IDnum\cf6 ,\cf4  age\cf6 ,\cf4  resiAddress\cf6 ,\cf4  walletAddress\cf6 );\cf4 \
          customerCnt\cf6 ++;\cf4 \
        \cf6 \}\cf4 \
\
        \cf2 // Car Renting database: record cars that were rented and to which wallet address \cf4 \
        records\cf6 [\cf4 recordCnt\cf6 ]\cf4  \cf6 =\cf4  rentalHistory\cf6 (\cf4 cars\cf6 [\cf4 carID\cf6 ].\cf4 carPlate\cf6 ,\cf4  Name\cf6 ,\cf4  walletAddress\cf6 ,\cf4  \cf10 msg\cf6 .\cf4 value\cf6 ,\cf4  \cf10 block\cf6 .\cf4 timestamp\cf6 ,\cf4  \
                                           \cf10 block\cf6 .\cf4 timestamp \cf6 +\cf4  \cf6 (\cf4 duration \cf6 *\cf4  \cf7 1\cf4  days\cf6 ),\cf4  duration\cf6 ,\cf4  \cf5 false\cf6 ,\cf4  \cf7 0\cf6 );\cf4 \
        \
        cars\cf6 [\cf4 carID\cf6 ].\cf4 carAvailable \cf6 =\cf4  \cf5 false\cf6 ;\cf4  \cf2 // update car availability\cf4 \
        recordCnt\cf6 ++;\cf4 \
        \
\
        \cf2 // As number of car available has reduced by 1, return the 10ETH deposited by company during listing\cf4 \
        \cf5 uint\cf4  companyDeposit \cf6 =\cf4  \cf7 10\cf4  ether\cf6 ;\cf4 \
        contractBalance \cf6 =\cf4  contractBalance \cf6 -\cf4  companyDeposit\cf6 ;\cf4 \
        company\cf6 .\cf4 transfer\cf6 (\cf7 10\cf4  ether\cf6 );\cf4 \
    \cf6 \}\cf4 \
\
    \cf2 // Flow 6 & 7: return car and update state\cf4 \
    \cf2 // Company key in end date, then calculate total renting cost base on days rented.\cf4 \
    \cf2 // If the car is damaged, company will key in the amount to charge that will be added to total renting cost\cf4 \
    \cf2 // deduct total renting cost from deposit, any surplus return.\cf4 \
    \cf5 function\cf4  confirmReturn\cf6 (\cf5 string\cf4  \cf14 memory\cf4  carPlateNum\cf6 ,\cf4  \cf5 uint\cf4  damageCharge\cf6 ,\cf4  \cf5 uint\cf4  returnYear\cf6 ,\cf4  \cf5 uint\cf4  returnMonth\cf6 ,\cf4  \cf5 uint\cf4  returnDay\cf6 )\cf4  \
    \cf8 payable\cf4  \cf8 public\cf4  isCompany \cf6 \{\cf4 \
      \cf5 uint\cf4  recordIndex \cf6 =\cf4  \cf7 0\cf6 ;\cf4 \
      \cf5 uint\cf4  carIndex \cf6 =\cf4  \cf7 0\cf6 ;\cf4 \
      \cf5 bool\cf4  returnValid \cf6 =\cf4  \cf5 false\cf6 ;\cf4 \
      \
      \cf2 // Check records and car list to ensure car is rented by customer, and get the wallet address of the customer\cf4 \
      \cf13 for\cf4  \cf6 (\cf5 uint\cf4  i \cf6 =\cf4  recordCnt\cf6 ;\cf4  i \cf6 >\cf4  \cf7 0\cf6 ;\cf4  i\cf6 --)\cf4  \cf6 \{\cf4 \
        \cf12 if\cf4  \cf6 (\cf4  \cf10 keccak256\cf6 (\cf10 bytes\cf6 (\cf4 _toLower\cf6 (\cf4 records\cf6 [\cf4 i\cf6 -\cf7 1\cf6 ].\cf4 carPlate\cf6 )))\cf4  \cf6 ==\cf4  \cf10 keccak256\cf6 (\cf10 bytes\cf6 (\cf4 _toLower\cf6 (\cf4 carPlateNum\cf6 )))\cf4  \cf6 )\cf4  \cf6 \{\cf4 \
          recordIndex \cf6 =\cf4  i\cf6 -\cf7 1\cf6 ;\cf4 \
          returnValid \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
          \cf13 break\cf6 ;\cf4 \
        \cf6 \}\cf4 \
      \cf6 \}\cf4 \
      \cf10 require\cf6 (\cf4 returnValid\cf6 ,\cf4  \cf11 "This car is not rented by customer."\cf6 );\cf4 \
\
      \cf13 for\cf4  \cf6 (\cf5 uint\cf4  j \cf6 =\cf4  \cf7 0\cf6 ;\cf4  j \cf6 <\cf4  carCnt\cf6 ;\cf4  j\cf6 ++)\cf4  \cf6 \{\cf4 \
        \cf12 if\cf4  \cf6 (\cf4  \cf10 keccak256\cf6 (\cf10 bytes\cf6 (\cf4 _toLower\cf6 (\cf4 cars\cf6 [\cf4 j\cf6 ].\cf4 carPlate\cf6 )))\cf4  \cf6 ==\cf4  \cf10 keccak256\cf6 (\cf10 bytes\cf6 (\cf4 _toLower\cf6 (\cf4 carPlateNum\cf6 )))\cf4  \cf6 )\cf4  \cf6 \{\cf4 \
          carIndex \cf6 =\cf4  j\cf6 ;\cf4 \
          \cf13 break\cf6 ;\cf4 \
        \cf6 \}\cf4 \
      \cf6 \}\cf4 \
\
      \cf2 // Final check to make sure this is the right car we looking at. \cf4 \
      \cf10 require\cf6 (\cf4 cars\cf6 [\cf4 carIndex\cf6 ].\cf4 carAvailable \cf6 ==\cf4  \cf5 false\cf6 ,\cf4  \cf11 "The car is not rented by customer."\cf6 );\cf4 \
      \cf10 require\cf6 (\cf4 records\cf6 [\cf4 recordIndex\cf6 ].\cf4 carReturned \cf6 ==\cf4  \cf5 false\cf6 ,\cf4  \cf11 "This car has already been returned."\cf6 );\cf4 \
\
      \cf2 // Check date is entered correctly\cf4 \
      \cf10 require\cf6 (\cf4 returnDay \cf6 <=\cf4  \cf7 31\cf4  \cf6 &&\cf4  returnDay \cf6 >=\cf4  \cf7 1\cf6 ,\cf4  \cf11 "Check your day entered!"\cf6 );\cf4 \
      \cf10 require\cf6 (\cf4 returnMonth \cf6 <=\cf4  \cf7 12\cf4  \cf6 &&\cf4  returnMonth \cf6 >=\cf4  \cf7 1\cf6 ,\cf4  \cf11 "Check your month entered!"\cf6 );\cf4 \
      \cf10 require\cf6 (\cf4 returnYear \cf6 ==\cf4  getYear\cf6 (\cf10 block\cf6 .\cf4 timestamp\cf6 ),\cf4  \cf11 "Year of return should be the current year now which the car is returned."\cf6 );\cf4 \
\
      \cf2 // To confirm the return, the company need send in 10ETH which will be used to relist the car later\cf4 \
      \cf10 require\cf6 (\cf10 msg\cf6 .\cf4 value \cf6 ==\cf4  \cf7 10\cf4  ether\cf6 ,\cf4  \cf11 "The company needs to send in 10ETH to confirm the car return and relist it."\cf6 );\cf4 \
\
      \cf2 // To get the rental information\cf4 \
      \cf5 address\cf4  \cf8 payable\cf4  _walletAdd \cf6 =\cf4  \cf8 payable\cf6 (\cf4 records\cf6 [\cf4 recordIndex\cf6 ].\cf4 walletAdd\cf6 );\cf4 \
      \cf2 // uint _depositAmt = records[recordIndex].depositAmt;\cf4 \
      \cf5 uint\cf4  _numOfDays \cf6 =\cf4  records\cf6 [\cf4 recordIndex\cf6 ].\cf4 numOfDays\cf6 ;\cf4 \
      \cf2 // uint _startDate = records[recordIndex].startDate;\cf4 \
      \cf2 // uint _carType = cars[carIndex].carType;\cf4 \
      \cf5 uint\cf4  rent \cf6 =\cf4  \cf7 1\cf4  ether\cf6 ;\cf4 \
      \cf5 uint\cf4  additionalCharge \cf6 =\cf4  \cf7 1\cf4  ether\cf6 ;\cf4  \
      \cf5 uint\cf4  surplusAmt \cf6 =\cf4  \cf7 0\cf4  ether\cf6 ;\cf4 \
      \cf5 uint\cf4  lateFee \cf6 =\cf4  \cf7 0\cf4  ether\cf6 ;\cf4 \
      \cf2 // uint returnDate = block.timestamp;\cf4 \
      \cf5 uint\cf4  returnDate \cf6 =\cf4  timestampFromDate\cf6 (\cf4 returnYear\cf6 ,\cf4  returnMonth\cf6 ,\cf4  returnDay\cf6 );\cf4 \
\
      \cf2 // Update the return date in records\cf4 \
      records\cf6 [\cf4 recordIndex\cf6 ].\cf4 endDate \cf6 =\cf4  returnDate\cf6 ;\cf4 \
\
      \cf2 // check car type that was rented, default is 1 ether for 4-seater\cf4 \
      \cf12 if\cf4  \cf6 (\cf4 cars\cf6 [\cf4 carIndex\cf6 ].\cf4 carType \cf6 ==\cf4  \cf7 6\cf6 )\{\cf4 \
        rent \cf6 =\cf4  \cf7 2\cf4  ether\cf6 ;\cf4 \
      \cf6 \}\cf4  \
      \cf12 else\cf4  \cf12 if\cf4  \cf6 (\cf4 cars\cf6 [\cf4 carIndex\cf6 ].\cf4 carType \cf6 ==\cf4  \cf7 8\cf6 )\cf4  \cf6 \{\cf4 \
        rent \cf6 =\cf4  \cf7 3\cf4  ether\cf6 ;\cf4 \
      \cf6 \}\cf4 \
\
      \cf2 // Check if the car is returned late by calculating the days difference \cf4 \
      \cf2 //between startDate and endDate, and compare with numOfDays that user intended to rent.\cf4 \
      \cf5 uint\cf4  totalRentedDays \cf6 =\cf4  diffDays\cf6 (\cf4 records\cf6 [\cf4 recordIndex\cf6 ].\cf4 startDate\cf6 ,\cf4  returnDate\cf6 );\cf4 \
\
      \cf12 if\cf6 (\cf4 totalRentedDays \cf6 >\cf4  _numOfDays\cf6 )\cf4  \cf6 \{\cf4 \
        lateFee \cf6 =\cf4  rent \cf6 *\cf4  \cf6 (\cf4 totalRentedDays \cf6 -\cf4  _numOfDays\cf6 );\cf4  \cf2 //charge rent * number of days late\cf4 \
      \cf6 \}\cf4 \
\
      \cf2 // To calculate the total renting cost\cf4 \
      additionalCharge \cf6 =\cf4  additionalCharge \cf6 *\cf4  damageCharge\cf6 ;\cf4  \cf2 // convert to ether\cf4 \
      \cf5 uint\cf4  fee \cf6 =\cf4  _numOfDays \cf6 *\cf4  rent \cf6 +\cf4  additionalCharge \cf6 +\cf4  lateFee\cf6 ;\cf4 \
\
      \cf2 // update avail of the car by changing state to available\cf4 \
      cars\cf6 [\cf4 carIndex\cf6 ].\cf4 carAvailable \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
\
      \cf2 // Update record\cf4 \
      records\cf6 [\cf4 recordIndex\cf6 ].\cf4 carReturned \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
\
      \cf2 // Update the transfer of 10ETH from company account to relist the car. \cf4 \
      contractBalance \cf6 =\cf4  contractBalance \cf6 +\cf4  \cf7 10\cf4  ether\cf6 ;\cf4 \
\
      \cf2 // Check if deposit can cover the total fee\cf4 \
      \cf12 if\cf4  \cf6 (\cf4 records\cf6 [\cf4 recordIndex\cf6 ].\cf4 depositAmt \cf6 <=\cf4  fee\cf6 )\cf4  \cf6 \{\cf4 \
        \cf2 // log the deficit that we require from the user\cf4 \
        records\cf6 [\cf4 recordIndex\cf6 ].\cf4 outstandingFee \cf6 =\cf4  fee \cf6 -\cf4  records\cf6 [\cf4 recordIndex\cf6 ].\cf4 depositAmt\cf6 ;\cf4 \
\
        \cf2 // No surplus and we take all the deposit \cf4 \
        \cf2 // surplusAmt = 0 ether;\cf4 \
        contractBalance \cf6 =\cf4  contractBalance \cf6 -\cf4  records\cf6 [\cf4 recordIndex\cf6 ].\cf4 depositAmt\cf6 ;\cf4  \
        company\cf6 .\cf4 transfer\cf6 (\cf4 records\cf6 [\cf4 recordIndex\cf6 ].\cf4 depositAmt\cf6 );\cf4 \
      \cf6 \}\cf4 \
      \cf12 else\cf4  \cf6 \{\cf4  \
        surplusAmt \cf6 =\cf4  records\cf6 [\cf4 recordIndex\cf6 ].\cf4 depositAmt \cf6 -\cf4  fee\cf6 ;\cf4 \
        \
        \cf2 // update contractbalance\cf4 \
        contractBalance \cf6 =\cf4  contractBalance \cf6 -\cf4  surplusAmt\cf6 ;\cf4 \
        contractBalance \cf6 =\cf4  contractBalance \cf6 -\cf4  fee\cf6 ;\cf4 \
\
        \cf2 // Transfer surplus to customer\cf4 \
        _walletAdd\cf6 .\cf4 transfer\cf6 (\cf4 surplusAmt\cf6 );\cf4 \
\
        \cf2 // Transfer fee earnings to company\cf4 \
        company\cf6 .\cf4 transfer\cf6 (\cf4 fee\cf6 );\cf4 \
      \cf6 \}\cf4 \
\
      \cf2 // Ensure no overflow for the surplus, definitely will be between 0 and a value less than the deposit\cf4 \
      \cf10 require\cf6 (\cf4 surplusAmt \cf6 >=\cf4  \cf7 0\cf4  \cf6 &&\cf4  surplusAmt \cf6 <\cf4  records\cf6 [\cf4 recordIndex\cf6 ].\cf4 depositAmt\cf6 ,\cf4  \cf11 "Customer's deposit not enough to cover the additional damage charge, topup required!"\cf6 );\cf4 \
    \cf6 \}\cf4 \
\
\
    \cf2 // Pay outstanding fees if needed\cf4 \
    \cf5 function\cf4  ChecknPayOutstanding\cf6 (\cf5 address\cf4  walletAddress\cf6 )\cf4  \
    \cf8 payable\cf4  \cf8 public\cf4  \cf6 \{\cf4 \
      \cf10 require\cf6 (\cf10 msg\cf6 .\cf4 sender \cf6 ==\cf4  walletAddress\cf6 ,\cf4  \cf11 "You need to be the owner of this wallet address to pay outstanding fees."\cf6 );\cf4 \
      \cf5 address\cf4  \cf8 payable\cf4  _walletAdd \cf6 =\cf4  \cf8 payable\cf6 (\cf4 walletAddress\cf6 );\cf4 \
\
      \cf5 bool\cf4  needPay \cf6 =\cf4  \cf5 true\cf6 ;\cf4 \
      \cf5 uint\cf4  ind \cf6 =\cf4  \cf7 0\cf6 ;\cf4 \
      \cf5 uint\cf4  surplus \cf6 =\cf4  \cf7 0\cf4  ether\cf6 ;\cf4 \
\
      \cf13 for\cf4  \cf6 (\cf5 uint\cf4  i \cf6 =\cf4  recordCnt\cf6 ;\cf4  i \cf6 >\cf4  \cf7 0\cf6 ;\cf4  i\cf6 --)\cf4  \cf6 \{\cf4 \
        \cf12 if\cf4  \cf6 (\cf4 records\cf6 [\cf4 i\cf6 -\cf7 1\cf6 ].\cf4 walletAdd \cf6 ==\cf4  walletAddress \cf6 &&\cf4  records\cf6 [\cf4 i\cf6 -\cf7 1\cf6 ].\cf4 outstandingFee \cf6 ==\cf4  \cf7 0\cf4  ether\cf6 )\cf4  \cf6 \{\cf4 \
          \cf2 // If the latest record available for this wallet address shows no outstanding fee, renter is allowed to rent \cf4 \
          needPay \cf6 =\cf4  \cf5 false\cf6 ;\cf4 \
          \cf13 break\cf6 ;\cf4 \
        \cf6 \}\cf4 \
        \cf12 else\cf4  \cf12 if\cf4  \cf6 (\cf4 records\cf6 [\cf4 i\cf6 -\cf7 1\cf6 ].\cf4 walletAdd \cf6 ==\cf4  walletAddress \cf6 &&\cf4  records\cf6 [\cf4 i\cf6 -\cf7 1\cf6 ].\cf4 outstandingFee \cf6 !=\cf4  \cf7 0\cf4  ether\cf6 )\cf4  \cf6 \{\cf4 \
          \cf2 // found the record index where this wallet address has an outstanding fine\cf4 \
          ind \cf6 =\cf4  i\cf6 -\cf7 1\cf6 ;\cf4 \
        \cf6 \}\cf4 \
      \cf6 \}\cf4 \
\
      \cf10 require\cf6 (\cf4 needPay \cf6 ==\cf4  \cf5 true\cf6 ,\cf4  \cf11 "You have no outstanding fees to pay! Go ahead and rent a car!"\cf6 );\cf4 \
\
      \cf12 if\cf4  \cf6 (\cf4 records\cf6 [\cf4 ind\cf6 ].\cf4 outstandingFee \cf6 >\cf4  \cf7 0\cf4  ether \cf6 &&\cf4  records\cf6 [\cf4 ind\cf6 ].\cf4 outstandingFee \cf6 <\cf4  \cf7 100\cf4  ether\cf6 )\cf4  \cf6 \{\cf4 \
        \cf2 // require(msg.value >= 10 ether, "Please send at least 10 ETH to pay your outstanding fine. Surplus will be returned to you.");\cf4 \
        \cf10 require\cf6 (\cf10 msg\cf6 .\cf4 value \cf6 >=\cf4  records\cf6 [\cf4 ind\cf6 ].\cf4 outstandingFee\cf6 ,\cf4  \cf5 string\cf6 (\cf10 abi\cf6 .\cf4 encodePacked\cf6 (\cf11 "Please pay for the outstanding ether: "\cf6 ,\cf4  uint2str\cf6 (\cf4 records\cf6 [\cf4 ind\cf6 ].\cf4 outstandingFee\cf6 /\cf7 1000000000000000000\cf6 ))));\cf4 \
        surplus \cf6 =\cf4  \cf10 msg\cf6 .\cf4 value \cf6 -\cf4  records\cf6 [\cf4 ind\cf6 ].\cf4 outstandingFee\cf6 ;\cf4 \
        records\cf6 [\cf4 ind\cf6 ].\cf4 outstandingFee \cf6 =\cf4  \cf7 0\cf4  ether\cf6 ;\cf4 \
        company\cf6 .\cf4 transfer\cf6 (\cf4 records\cf6 [\cf4 ind\cf6 ].\cf4 outstandingFee\cf6 );\cf4  \
        _walletAdd\cf6 .\cf4 transfer\cf6 (\cf4 surplus\cf6 );\cf4 \
      \cf6 \}\cf4 \
\
      \cf2 // if (records[ind].outstandingFee >= 10  && records[ind].outstandingFee < 100) \{\cf4 \
      \cf2 //   require(msg.value >= 100 ether, "Please send at least 100 ETH to pay your outstanding fine. Surplus will be returned to you.");\cf4 \
      \cf2 //   surplus = msg.value - records[ind].outstandingFee;\cf4 \
      \cf2 //   records[ind].outstandingFee = 0;\cf4 \
      \cf2 //   company.transfer(records[ind].outstandingFee); \cf4 \
      \cf2 //   _walletAdd.transfer(surplus);\cf4 \
      \cf2 // \}\cf4 \
\
      \cf12 if\cf4  \cf6 (\cf4 records\cf6 [\cf4 ind\cf6 ].\cf4 outstandingFee \cf6 >=\cf4  \cf7 100\cf4  ether\cf6 )\cf4  \cf6 \{\cf4 \
        needPay \cf6 =\cf4  \cf5 false\cf6 ;\cf4 \
        \cf10 require\cf6 (\cf4 needPay \cf6 ==\cf4  \cf5 true\cf6 ,\cf4  \cf11 "Your outstanding fee is too large and thus have been blacklisted from rental. Please contact a representative from ABC Rental Company for settlement."\cf6 );\cf4 \
      \cf6 \}\cf4 \
\
      \cf10 require\cf6 (\cf4 recordCnt \cf6 >\cf4  \cf7 0\cf6 ,\cf4  \cf11 "There is no outstanding associated thus far!"\cf6 );\cf4 \
    \cf6 \}\cf4 \
\
\
  \cf2 /********************************************************************************************************/\cf4 \
  \cf2 /*                                          Helper Functions                                            */\cf4 \
  \cf2 /********************************************************************************************************/\cf4 \
\
    \cf2 // Convert strings to lowercase \cf4 \
    \cf5 function\cf4  _toLower\cf6 (\cf5 string\cf4  \cf14 memory\cf4  str\cf6 )\cf4  \cf8 internal\cf4  \cf8 pure\cf4  \cf15 returns\cf4  \cf6 (\cf5 string\cf4  \cf14 memory\cf6 )\cf4  \cf6 \{\cf4 \
        \cf10 bytes\cf4  \cf14 memory\cf4  bStr \cf6 =\cf4  \cf10 bytes\cf6 (\cf4 str\cf6 );\cf4 \
        \cf10 bytes\cf4  \cf14 memory\cf4  bLower \cf6 =\cf4  \cf5 new\cf4  \cf10 bytes\cf6 (\cf4 bStr\cf6 .\cf4 length\cf6 );\cf4 \
        \cf13 for\cf4  \cf6 (\cf5 uint\cf4  i \cf6 =\cf4  \cf7 0\cf6 ;\cf4  i \cf6 <\cf4  bStr\cf6 .\cf4 length\cf6 ;\cf4  i\cf6 ++)\cf4  \cf6 \{\cf4 \
            \cf2 // Uppercase character...\cf4 \
            \cf12 if\cf4  \cf6 ((\cf5 uint8\cf6 (\cf4 bStr\cf6 [\cf4 i\cf6 ])\cf4  \cf6 >=\cf4  \cf7 65\cf6 )\cf4  \cf6 &&\cf4  \cf6 (\cf5 uint8\cf6 (\cf4 bStr\cf6 [\cf4 i\cf6 ])\cf4  \cf6 <=\cf4  \cf7 90\cf6 ))\cf4  \cf6 \{\cf4 \
                \cf2 // So we add 32 to make it lowercase\cf4 \
                bLower\cf6 [\cf4 i\cf6 ]\cf4  \cf6 =\cf4  \cf5 bytes1\cf6 (\cf5 uint8\cf6 (\cf4 bStr\cf6 [\cf4 i\cf6 ])\cf4  \cf6 +\cf4  \cf7 32\cf6 );\cf4 \
            \cf6 \}\cf4  \cf12 else\cf4  \cf6 \{\cf4 \
                bLower\cf6 [\cf4 i\cf6 ]\cf4  \cf6 =\cf4  bStr\cf6 [\cf4 i\cf6 ];\cf4 \
            \cf6 \}\cf4 \
        \cf6 \}\cf4 \
        \cf15 return\cf4  \cf5 string\cf6 (\cf4 bLower\cf6 );\cf4 \
    \cf6 \}\cf4 \
    \
    \cf2 // Convert uint25 to string\cf4 \
    \cf5 function\cf4  uint2str\cf6 (\cf5 uint256\cf4  _i\cf6 )\cf4  \cf8 internal\cf4  \cf8 pure\cf4  \cf15 returns\cf4  \cf6 (\cf5 string\cf4  \cf14 memory\cf4  str\cf6 )\cf4  \cf6 \{\cf4 \
      \cf12 if\cf4  \cf6 (\cf4 _i \cf6 ==\cf4  \cf7 0\cf6 )\cf4  \cf6 \{\cf4 \
        \cf15 return\cf4  \cf11 "0"\cf6 ;\cf4 \
        \cf6 \}\cf4 \
        \cf5 uint256\cf4  j \cf6 =\cf4  _i\cf6 ;\cf4 \
        \cf5 uint256\cf4  length\cf6 ;\cf4 \
        \cf13 while\cf4  \cf6 (\cf4 j \cf6 !=\cf4  \cf7 0\cf6 )\cf4  \cf6 \{\cf4 \
          length\cf6 ++;\cf4 \
          j \cf6 /=\cf4  \cf7 10\cf6 ;\cf4 \
          \cf6 \}\cf4 \
          \cf10 bytes\cf4  \cf14 memory\cf4  bstr \cf6 =\cf4  \cf5 new\cf4  \cf10 bytes\cf6 (\cf4 length\cf6 );\cf4 \
          \cf5 uint256\cf4  k \cf6 =\cf4  length\cf6 ;\cf4 \
          j \cf6 =\cf4  _i\cf6 ;\cf4 \
          \cf13 while\cf4  \cf6 (\cf4 j \cf6 !=\cf4  \cf7 0\cf6 )\cf4  \cf6 \{\cf4 \
            bstr\cf6 [--\cf4 k\cf6 ]\cf4  \cf6 =\cf4  \cf5 bytes1\cf6 (\cf5 uint8\cf6 (\cf7 48\cf4  \cf6 +\cf4  j \cf6 %\cf4  \cf7 10\cf6 ));\cf4 \
            j \cf6 /=\cf4  \cf7 10\cf6 ;\cf4 \
            \cf6 \}\cf4 \
            str \cf6 =\cf4  \cf5 string\cf6 (\cf4 bstr\cf6 );\cf4 \
            \cf6 \}\cf4 \
\
\
    \cf2 // Datetime function from BokkyPooBahs: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\cf4 \
    \cf2 // uint SECONDS_PER_DAY = 24 * 60 * 60;\cf4 \
    \cf5 function\cf4  _daysFromDate\cf6 (\cf5 uint\cf4  year\cf6 ,\cf4  \cf5 uint\cf4  month\cf6 ,\cf4  \cf5 uint\cf4  day\cf6 )\cf4  \cf8 internal\cf4  \cf8 pure\cf4  \cf15 returns\cf4  \cf6 (\cf5 uint\cf4  _days\cf6 )\cf4  \cf6 \{\cf4 \
        \cf5 int\cf4  OFFSET19700101 \cf6 =\cf4  \cf7 2440588\cf6 ;\cf4 \
        \cf10 require\cf6 (\cf4 year \cf6 >=\cf4  \cf7 1970\cf6 );\cf4 \
        \cf5 int\cf4  _year \cf6 =\cf4  \cf5 int\cf6 (\cf4 year\cf6 );\cf4 \
        \cf5 int\cf4  _month \cf6 =\cf4  \cf5 int\cf6 (\cf4 month\cf6 );\cf4 \
        \cf5 int\cf4  _day \cf6 =\cf4  \cf5 int\cf6 (\cf4 day\cf6 );\cf4 \
\
        \cf5 int\cf4  __days \cf6 =\cf4  _day\
          \cf6 -\cf4  \cf7 32075\cf4 \
          \cf6 +\cf4  \cf7 1461\cf4  \cf6 *\cf4  \cf6 (\cf4 _year \cf6 +\cf4  \cf7 4800\cf4  \cf6 +\cf4  \cf6 (\cf4 _month \cf6 -\cf4  \cf7 14\cf6 )\cf4  \cf6 /\cf4  \cf7 12\cf6 )\cf4  \cf6 /\cf4  \cf7 4\cf4 \
          \cf6 +\cf4  \cf7 367\cf4  \cf6 *\cf4  \cf6 (\cf4 _month \cf6 -\cf4  \cf7 2\cf4  \cf6 -\cf4  \cf6 (\cf4 _month \cf6 -\cf4  \cf7 14\cf6 )\cf4  \cf6 /\cf4  \cf7 12\cf4  \cf6 *\cf4  \cf7 12\cf6 )\cf4  \cf6 /\cf4  \cf7 12\cf4 \
          \cf6 -\cf4  \cf7 3\cf4  \cf6 *\cf4  \cf6 ((\cf4 _year \cf6 +\cf4  \cf7 4900\cf4  \cf6 +\cf4  \cf6 (\cf4 _month \cf6 -\cf4  \cf7 14\cf6 )\cf4  \cf6 /\cf4  \cf7 12\cf6 )\cf4  \cf6 /\cf4  \cf7 100\cf6 )\cf4  \cf6 /\cf4  \cf7 4\cf4 \
          \cf6 -\cf4  OFFSET19700101\cf6 ;\cf4 \
\
        _days \cf6 =\cf4  \cf5 uint\cf6 (\cf4 __days\cf6 );\cf4 \
    \cf6 \}\cf4 \
    \cf5 function\cf4  _daysToDate\cf6 (\cf5 uint\cf4  _days\cf6 )\cf4  \cf8 internal\cf4  \cf8 pure\cf4  \cf15 returns\cf4  \cf6 (\cf5 uint\cf4  year\cf6 ,\cf4  \cf5 uint\cf4  month\cf6 ,\cf4  \cf5 uint\cf4  day\cf6 )\cf4  \cf6 \{\cf4 \
        \cf5 int\cf4  __days \cf6 =\cf4  \cf5 int\cf6 (\cf4 _days\cf6 );\cf4 \
        \cf5 int\cf4  OFFSET19700101 \cf6 =\cf4  \cf7 2440588\cf6 ;\cf4 \
\
        \cf5 int\cf4  L \cf6 =\cf4  __days \cf6 +\cf4  \cf7 68569\cf4  \cf6 +\cf4  OFFSET19700101\cf6 ;\cf4 \
        \cf5 int\cf4  N \cf6 =\cf4  \cf7 4\cf4  \cf6 *\cf4  L \cf6 /\cf4  \cf7 146097\cf6 ;\cf4 \
        L \cf6 =\cf4  L \cf6 -\cf4  \cf6 (\cf7 146097\cf4  \cf6 *\cf4  N \cf6 +\cf4  \cf7 3\cf6 )\cf4  \cf6 /\cf4  \cf7 4\cf6 ;\cf4 \
        \cf5 int\cf4  _year \cf6 =\cf4  \cf7 4000\cf4  \cf6 *\cf4  \cf6 (\cf4 L \cf6 +\cf4  \cf7 1\cf6 )\cf4  \cf6 /\cf4  \cf7 1461001\cf6 ;\cf4 \
        L \cf6 =\cf4  L \cf6 -\cf4  \cf7 1461\cf4  \cf6 *\cf4  _year \cf6 /\cf4  \cf7 4\cf4  \cf6 +\cf4  \cf7 31\cf6 ;\cf4 \
        \cf5 int\cf4  _month \cf6 =\cf4  \cf7 80\cf4  \cf6 *\cf4  L \cf6 /\cf4  \cf7 2447\cf6 ;\cf4 \
        \cf5 int\cf4  _day \cf6 =\cf4  L \cf6 -\cf4  \cf7 2447\cf4  \cf6 *\cf4  _month \cf6 /\cf4  \cf7 80\cf6 ;\cf4 \
        L \cf6 =\cf4  _month \cf6 /\cf4  \cf7 11\cf6 ;\cf4 \
        _month \cf6 =\cf4  _month \cf6 +\cf4  \cf7 2\cf4  \cf6 -\cf4  \cf7 12\cf4  \cf6 *\cf4  L\cf6 ;\cf4 \
        _year \cf6 =\cf4  \cf7 100\cf4  \cf6 *\cf4  \cf6 (\cf4 N \cf6 -\cf4  \cf7 49\cf6 )\cf4  \cf6 +\cf4  _year \cf6 +\cf4  L\cf6 ;\cf4 \
\
        year \cf6 =\cf4  \cf5 uint\cf6 (\cf4 _year\cf6 );\cf4 \
        month \cf6 =\cf4  \cf5 uint\cf6 (\cf4 _month\cf6 );\cf4 \
        day \cf6 =\cf4  \cf5 uint\cf6 (\cf4 _day\cf6 );\cf4 \
    \cf6 \}\cf4 \
    \
    \cf5 function\cf4  timestampFromDate\cf6 (\cf5 uint\cf4  year\cf6 ,\cf4  \cf5 uint\cf4  month\cf6 ,\cf4  \cf5 uint\cf4  day\cf6 )\cf4  \cf8 internal\cf4  \cf8 pure\cf4  \cf15 returns\cf4  \cf6 (\cf5 uint\cf4  timestamp\cf6 )\cf4  \cf6 \{\cf4 \
        \cf5 uint\cf4  SECONDS_PER_DAY \cf6 =\cf4  \cf7 24\cf4  \cf6 *\cf4  \cf7 60\cf4  \cf6 *\cf4  \cf7 60\cf6 ;\cf4 \
        timestamp \cf6 =\cf4  _daysFromDate\cf6 (\cf4 year\cf6 ,\cf4  month\cf6 ,\cf4  day\cf6 )\cf4  \cf6 *\cf4  SECONDS_PER_DAY\cf6 ;\cf4 \
    \cf6 \}\cf4 \
\
    \cf5 function\cf4  diffDays\cf6 (\cf5 uint\cf4  fromTimestamp\cf6 ,\cf4  \cf5 uint\cf4  toTimestamp\cf6 )\cf4  \cf8 internal\cf4  \cf8 pure\cf4  \cf15 returns\cf4  \cf6 (\cf5 uint\cf4  _days\cf6 )\cf4  \cf6 \{\cf4 \
        \cf5 uint\cf4  SECONDS_PER_DAY \cf6 =\cf4  \cf7 24\cf4  \cf6 *\cf4  \cf7 60\cf4  \cf6 *\cf4  \cf7 60\cf6 ;\cf4 \
        \cf10 require\cf6 (\cf4 fromTimestamp \cf6 <=\cf4  toTimestamp\cf6 );\cf4 \
        _days \cf6 =\cf4  \cf6 (\cf4 toTimestamp \cf6 -\cf4  fromTimestamp\cf6 )\cf4  \cf6 /\cf4  SECONDS_PER_DAY\cf6 ;\cf4 \
    \cf6 \}\cf4 \
\
    \cf5 function\cf4  getYear\cf6 (\cf5 uint\cf4  timestamp\cf6 )\cf4  \cf8 internal\cf4  \cf8 pure\cf4  \cf15 returns\cf4  \cf6 (\cf5 uint\cf4  year\cf6 )\cf4  \cf6 \{\cf4 \
        \cf5 uint\cf4  SECONDS_PER_DAY \cf6 =\cf4  \cf7 24\cf4  \cf6 *\cf4  \cf7 60\cf4  \cf6 *\cf4  \cf7 60\cf6 ;\cf4 \
        \cf6 (\cf4 year\cf6 ,,)\cf4  \cf6 =\cf4  _daysToDate\cf6 (\cf4 timestamp \cf6 /\cf4  SECONDS_PER_DAY\cf6 );\cf4 \
    \cf6 \}\cf4 \
\cf6 \}\cf4 \
\
\
}